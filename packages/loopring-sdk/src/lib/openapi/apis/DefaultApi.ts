/* tslint:disable */
/* eslint-disable */
/**
 * SDK for Loopring Layer 2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccountInfo,
  CounterfactualWalletInfo,
  LockAssetRequest,
  LockAssetResponse,
  NFTMintRequestV3,
  NextStorageIdInfo,
  OffchainFeeInfo,
  ResolveNameInfo,
  ResultInfo,
  TradeNftRequest,
  TradeNftResponse,
  TxHashInfo,
  UnlockAssetRequest,
  UserApiKey,
  UserNftBalancesInfo,
} from '../models/index';
import {
    AccountInfoFromJSON,
    AccountInfoToJSON,
    CounterfactualWalletInfoFromJSON,
    CounterfactualWalletInfoToJSON,
    LockAssetRequestFromJSON,
    LockAssetRequestToJSON,
    LockAssetResponseFromJSON,
    LockAssetResponseToJSON,
    NFTMintRequestV3FromJSON,
    NFTMintRequestV3ToJSON,
    NextStorageIdInfoFromJSON,
    NextStorageIdInfoToJSON,
    OffchainFeeInfoFromJSON,
    OffchainFeeInfoToJSON,
    ResolveNameInfoFromJSON,
    ResolveNameInfoToJSON,
    ResultInfoFromJSON,
    ResultInfoToJSON,
    TradeNftRequestFromJSON,
    TradeNftRequestToJSON,
    TradeNftResponseFromJSON,
    TradeNftResponseToJSON,
    TxHashInfoFromJSON,
    TxHashInfoToJSON,
    UnlockAssetRequestFromJSON,
    UnlockAssetRequestToJSON,
    UserApiKeyFromJSON,
    UserApiKeyToJSON,
    UserNftBalancesInfoFromJSON,
    UserNftBalancesInfoToJSON,
} from '../models/index';

export interface GetAccountRequest {
    owner?: string;
    accountId?: number;
}

export interface GetCounterFactualInfoRequest {
    accountId: number;
}

export interface GetNFTOffchainFeeRequest {
    accountId: number;
    requestType: GetNFTOffchainFeeRequestTypeEnum;
    tokenAddress?: string;
    xAPIKEY: string;
}

export interface GetNextStorageIdRequest {
    accountId: number;
    sellTokenId: number;
    maxNext?: boolean;
    xAPIKEY: string;
}

export interface GetUserApiKeyRequest {
    accountId: number;
    xAPISIG: string;
}

export interface GetUserNftBalancesRequest {
    accountId: number;
    nftDatas?: string;
    tokenAddrs?: string;
    tokenIds?: string;
    offset?: number;
    limit?: number;
    nonZero?: boolean;
    metadata?: boolean;
    xAPIKEY: string;
}

export interface LockAssetOperationRequest {
    xAPIKEY: string;
    xAPISIG: string;
    lockAssetRequest: LockAssetRequest;
}

export interface ResolveNameRequest {
    owner: string;
}

export interface SubmitNFTMintRequest {
    xAPIKEY: string;
    nFTMintRequestV3: NFTMintRequestV3;
}

export interface TradeNftOperationRequest {
    xAPIKEY: string;
    xAPISIG: string;
    tradeNftRequest: TradeNftRequest;
}

export interface UnlockAssetOperationRequest {
    xAPIKEY: string;
    xAPISIG: string;
    unlockAssetRequest: UnlockAssetRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * One of owner and accountId is required.
     * Get Account info
     */
    async getAccountRaw(requestParameters: GetAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountInfo>> {
        const queryParameters: any = {};

        if (requestParameters.owner !== undefined) {
            queryParameters['owner'] = requestParameters.owner;
        }

        if (requestParameters.accountId !== undefined) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v3/account`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountInfoFromJSON(jsonValue));
    }

    /**
     * One of owner and accountId is required.
     * Get Account info
     */
    async getAccount(requestParameters: GetAccountRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountInfo> {
        const response = await this.getAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Counterfactual Wallet Info
     */
    async getCounterFactualInfoRaw(requestParameters: GetCounterFactualInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CounterfactualWalletInfo>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getCounterFactualInfo.');
        }

        const queryParameters: any = {};

        if (requestParameters.accountId !== undefined) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v3/counterFactualInfo`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CounterfactualWalletInfoFromJSON(jsonValue));
    }

    /**
     * Counterfactual Wallet Info
     */
    async getCounterFactualInfo(requestParameters: GetCounterFactualInfoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CounterfactualWalletInfo> {
        const response = await this.getCounterFactualInfoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * GET NFT Offchain Fee
     */
    async getNFTOffchainFeeRaw(requestParameters: GetNFTOffchainFeeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OffchainFeeInfo>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getNFTOffchainFee.');
        }

        if (requestParameters.requestType === null || requestParameters.requestType === undefined) {
            throw new runtime.RequiredError('requestType','Required parameter requestParameters.requestType was null or undefined when calling getNFTOffchainFee.');
        }

        if (requestParameters.xAPIKEY === null || requestParameters.xAPIKEY === undefined) {
            throw new runtime.RequiredError('xAPIKEY','Required parameter requestParameters.xAPIKEY was null or undefined when calling getNFTOffchainFee.');
        }

        const queryParameters: any = {};

        if (requestParameters.accountId !== undefined) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        if (requestParameters.requestType !== undefined) {
            queryParameters['requestType'] = requestParameters.requestType;
        }

        if (requestParameters.tokenAddress !== undefined) {
            queryParameters['tokenAddress'] = requestParameters.tokenAddress;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAPIKEY !== undefined && requestParameters.xAPIKEY !== null) {
            headerParameters['X-API-KEY'] = String(requestParameters.xAPIKEY);
        }

        const response = await this.request({
            path: `/api/v3/user/nft/offchainFee`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OffchainFeeInfoFromJSON(jsonValue));
    }

    /**
     * GET NFT Offchain Fee
     */
    async getNFTOffchainFee(requestParameters: GetNFTOffchainFeeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OffchainFeeInfo> {
        const response = await this.getNFTOffchainFeeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one.
     * Storage Id
     */
    async getNextStorageIdRaw(requestParameters: GetNextStorageIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NextStorageIdInfo>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getNextStorageId.');
        }

        if (requestParameters.sellTokenId === null || requestParameters.sellTokenId === undefined) {
            throw new runtime.RequiredError('sellTokenId','Required parameter requestParameters.sellTokenId was null or undefined when calling getNextStorageId.');
        }

        if (requestParameters.xAPIKEY === null || requestParameters.xAPIKEY === undefined) {
            throw new runtime.RequiredError('xAPIKEY','Required parameter requestParameters.xAPIKEY was null or undefined when calling getNextStorageId.');
        }

        const queryParameters: any = {};

        if (requestParameters.accountId !== undefined) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        if (requestParameters.sellTokenId !== undefined) {
            queryParameters['sellTokenId'] = requestParameters.sellTokenId;
        }

        if (requestParameters.maxNext !== undefined) {
            queryParameters['maxNext'] = requestParameters.maxNext;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAPIKEY !== undefined && requestParameters.xAPIKEY !== null) {
            headerParameters['X-API-KEY'] = String(requestParameters.xAPIKEY);
        }

        const response = await this.request({
            path: `/api/v3/storageId`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NextStorageIdInfoFromJSON(jsonValue));
    }

    /**
     * Fetches the next order id for a given sold token. If the need arises to repeatedly place orders in a short span of time, the order id can be initially fetched through the API and then managed locally. Each new order id can be derived from adding 2 to the last one.
     * Storage Id
     */
    async getNextStorageId(requestParameters: GetNextStorageIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NextStorageIdInfo> {
        const response = await this.getNextStorageIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the ApiKey associated with the user\'s account
     */
    async getUserApiKeyRaw(requestParameters: GetUserApiKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserApiKey>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getUserApiKey.');
        }

        if (requestParameters.xAPISIG === null || requestParameters.xAPISIG === undefined) {
            throw new runtime.RequiredError('xAPISIG','Required parameter requestParameters.xAPISIG was null or undefined when calling getUserApiKey.');
        }

        const queryParameters: any = {};

        if (requestParameters.accountId !== undefined) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAPISIG !== undefined && requestParameters.xAPISIG !== null) {
            headerParameters['X-API-SIG'] = String(requestParameters.xAPISIG);
        }

        const response = await this.request({
            path: `/api/v3/apiKey`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserApiKeyFromJSON(jsonValue));
    }

    /**
     * Get the ApiKey associated with the user\'s account
     */
    async getUserApiKey(requestParameters: GetUserApiKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserApiKey> {
        const response = await this.getUserApiKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get users NFT balance, besides amount, it also includes tokenId and nftData
     */
    async getUserNftBalancesRaw(requestParameters: GetUserNftBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserNftBalancesInfo>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling getUserNftBalances.');
        }

        if (requestParameters.xAPIKEY === null || requestParameters.xAPIKEY === undefined) {
            throw new runtime.RequiredError('xAPIKEY','Required parameter requestParameters.xAPIKEY was null or undefined when calling getUserNftBalances.');
        }

        const queryParameters: any = {};

        if (requestParameters.accountId !== undefined) {
            queryParameters['accountId'] = requestParameters.accountId;
        }

        if (requestParameters.nftDatas !== undefined) {
            queryParameters['nftDatas'] = requestParameters.nftDatas;
        }

        if (requestParameters.tokenAddrs !== undefined) {
            queryParameters['tokenAddrs'] = requestParameters.tokenAddrs;
        }

        if (requestParameters.tokenIds !== undefined) {
            queryParameters['tokenIds'] = requestParameters.tokenIds;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.nonZero !== undefined) {
            queryParameters['nonZero'] = requestParameters.nonZero;
        }

        if (requestParameters.metadata !== undefined) {
            queryParameters['metadata'] = requestParameters.metadata;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.xAPIKEY !== undefined && requestParameters.xAPIKEY !== null) {
            headerParameters['X-API-KEY'] = String(requestParameters.xAPIKEY);
        }

        const response = await this.request({
            path: `/api/v3/user/nft/balances`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserNftBalancesInfoFromJSON(jsonValue));
    }

    /**
     * Get users NFT balance, besides amount, it also includes tokenId and nftData
     */
    async getUserNftBalances(requestParameters: GetUserNftBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserNftBalancesInfo> {
        const response = await this.getUserNftBalancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lock Asset.
     * Lock Asset
     */
    async lockAssetRaw(requestParameters: LockAssetOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LockAssetResponse>> {
        if (requestParameters.xAPIKEY === null || requestParameters.xAPIKEY === undefined) {
            throw new runtime.RequiredError('xAPIKEY','Required parameter requestParameters.xAPIKEY was null or undefined when calling lockAsset.');
        }

        if (requestParameters.xAPISIG === null || requestParameters.xAPISIG === undefined) {
            throw new runtime.RequiredError('xAPISIG','Required parameter requestParameters.xAPISIG was null or undefined when calling lockAsset.');
        }

        if (requestParameters.lockAssetRequest === null || requestParameters.lockAssetRequest === undefined) {
            throw new runtime.RequiredError('lockAssetRequest','Required parameter requestParameters.lockAssetRequest was null or undefined when calling lockAsset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAPIKEY !== undefined && requestParameters.xAPIKEY !== null) {
            headerParameters['X-API-KEY'] = String(requestParameters.xAPIKEY);
        }

        if (requestParameters.xAPISIG !== undefined && requestParameters.xAPISIG !== null) {
            headerParameters['X-API-SIG'] = String(requestParameters.xAPISIG);
        }

        const response = await this.request({
            path: `/api/v3/lockAssets`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LockAssetRequestToJSON(requestParameters.lockAssetRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LockAssetResponseFromJSON(jsonValue));
    }

    /**
     * Lock Asset.
     * Lock Asset
     */
    async lockAsset(requestParameters: LockAssetOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LockAssetResponse> {
        const response = await this.lockAssetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Resolve address to loopring ENS name
     */
    async resolveNameRaw(requestParameters: ResolveNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResolveNameInfo>> {
        if (requestParameters.owner === null || requestParameters.owner === undefined) {
            throw new runtime.RequiredError('owner','Required parameter requestParameters.owner was null or undefined when calling resolveName.');
        }

        const queryParameters: any = {};

        if (requestParameters.owner !== undefined) {
            queryParameters['owner'] = requestParameters.owner;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/wallet/v3/resolveName`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResolveNameInfoFromJSON(jsonValue));
    }

    /**
     * Resolve address to loopring ENS name
     */
    async resolveName(requestParameters: ResolveNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResolveNameInfo> {
        const response = await this.resolveNameRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * mint nft in Loopring layer2, only can mint ERC1155 in layer2 now.
     * Mint NFT
     */
    async submitNFTMintRaw(requestParameters: SubmitNFTMintRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TxHashInfo>> {
        if (requestParameters.xAPIKEY === null || requestParameters.xAPIKEY === undefined) {
            throw new runtime.RequiredError('xAPIKEY','Required parameter requestParameters.xAPIKEY was null or undefined when calling submitNFTMint.');
        }

        if (requestParameters.nFTMintRequestV3 === null || requestParameters.nFTMintRequestV3 === undefined) {
            throw new runtime.RequiredError('nFTMintRequestV3','Required parameter requestParameters.nFTMintRequestV3 was null or undefined when calling submitNFTMint.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAPIKEY !== undefined && requestParameters.xAPIKEY !== null) {
            headerParameters['X-API-KEY'] = String(requestParameters.xAPIKEY);
        }

        const response = await this.request({
            path: `/api/v3/nft/mint`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NFTMintRequestV3ToJSON(requestParameters.nFTMintRequestV3),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TxHashInfoFromJSON(jsonValue));
    }

    /**
     * mint nft in Loopring layer2, only can mint ERC1155 in layer2 now.
     * Mint NFT
     */
    async submitNFTMint(requestParameters: SubmitNFTMintRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TxHashInfo> {
        const response = await this.submitNFTMintRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trade NFT.
     * Trade NFT
     */
    async tradeNftRaw(requestParameters: TradeNftOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TradeNftResponse>> {
        if (requestParameters.xAPIKEY === null || requestParameters.xAPIKEY === undefined) {
            throw new runtime.RequiredError('xAPIKEY','Required parameter requestParameters.xAPIKEY was null or undefined when calling tradeNft.');
        }

        if (requestParameters.xAPISIG === null || requestParameters.xAPISIG === undefined) {
            throw new runtime.RequiredError('xAPISIG','Required parameter requestParameters.xAPISIG was null or undefined when calling tradeNft.');
        }

        if (requestParameters.tradeNftRequest === null || requestParameters.tradeNftRequest === undefined) {
            throw new runtime.RequiredError('tradeNftRequest','Required parameter requestParameters.tradeNftRequest was null or undefined when calling tradeNft.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAPIKEY !== undefined && requestParameters.xAPIKEY !== null) {
            headerParameters['X-API-KEY'] = String(requestParameters.xAPIKEY);
        }

        if (requestParameters.xAPISIG !== undefined && requestParameters.xAPISIG !== null) {
            headerParameters['X-API-SIG'] = String(requestParameters.xAPISIG);
        }

        const response = await this.request({
            path: `/api/v3/nft/trade`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TradeNftRequestToJSON(requestParameters.tradeNftRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TradeNftResponseFromJSON(jsonValue));
    }

    /**
     * Trade NFT.
     * Trade NFT
     */
    async tradeNft(requestParameters: TradeNftOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TradeNftResponse> {
        const response = await this.tradeNftRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unlock Asset.
     * Unlock Asset
     */
    async unlockAssetRaw(requestParameters: UnlockAssetOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LockAssetResponse>> {
        if (requestParameters.xAPIKEY === null || requestParameters.xAPIKEY === undefined) {
            throw new runtime.RequiredError('xAPIKEY','Required parameter requestParameters.xAPIKEY was null or undefined when calling unlockAsset.');
        }

        if (requestParameters.xAPISIG === null || requestParameters.xAPISIG === undefined) {
            throw new runtime.RequiredError('xAPISIG','Required parameter requestParameters.xAPISIG was null or undefined when calling unlockAsset.');
        }

        if (requestParameters.unlockAssetRequest === null || requestParameters.unlockAssetRequest === undefined) {
            throw new runtime.RequiredError('unlockAssetRequest','Required parameter requestParameters.unlockAssetRequest was null or undefined when calling unlockAsset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.xAPIKEY !== undefined && requestParameters.xAPIKEY !== null) {
            headerParameters['X-API-KEY'] = String(requestParameters.xAPIKEY);
        }

        if (requestParameters.xAPISIG !== undefined && requestParameters.xAPISIG !== null) {
            headerParameters['X-API-SIG'] = String(requestParameters.xAPISIG);
        }

        const response = await this.request({
            path: `/api/v3/unlockAssets`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnlockAssetRequestToJSON(requestParameters.unlockAssetRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LockAssetResponseFromJSON(jsonValue));
    }

    /**
     * Unlock Asset.
     * Unlock Asset
     */
    async unlockAsset(requestParameters: UnlockAssetOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LockAssetResponse> {
        const response = await this.unlockAssetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetNFTOffchainFeeRequestTypeEnum = {
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_13: 13,
    NUMBER_19: 19
} as const;
export type GetNFTOffchainFeeRequestTypeEnum = typeof GetNFTOffchainFeeRequestTypeEnum[keyof typeof GetNFTOffchainFeeRequestTypeEnum];
